;#include <mega88a.h>
;PCODE: $00000000 VOL: 0
	#ifndef __SLEEP_DEFINED__
;PCODE: $00000001 VOL: 0
	#define __SLEEP_DEFINED__
;PCODE: $00000002 VOL: 0
	.EQU __se_bit=0x01
;PCODE: $00000003 VOL: 0
	.EQU __sm_mask=0x0E
;PCODE: $00000004 VOL: 0
	.EQU __sm_adc_noise_red=0x02
;PCODE: $00000005 VOL: 0
	.EQU __sm_powerdown=0x04
;PCODE: $00000006 VOL: 0
	.EQU __sm_powersave=0x06
;PCODE: $00000007 VOL: 0
	.EQU __sm_standby=0x0C
;PCODE: $00000008 VOL: 0
	.EQU __sm_ext_standby=0x0E
;PCODE: $00000009 VOL: 0
	.SET power_ctrl_reg=smcr
;PCODE: $0000000A VOL: 0
	#endif
;PCODE: $0000000B VOL: 0
;PCODE: $0000000C VOL: 0
;// Standard Input/Output functions
;#include <stdio.h>
;#include <delay.h>
;
;#include "ade7753.h"
;
;// SPI functions
;#include <spi.h>
;#define CS_ADE PORTB.1=0
;#define NCS_ADE PORTB.1=1
;
;void setup(void)
; 0001 000E {

	.CSEG
;PCODE: $0000000D VOL: 0
;PCODE: $0000000E VOL: 0
; 0001 000F     // Settings for Olimex Energy Shield #1 - Etel
; 0001 0010     // ------------------------------------
; 0001 0011     //ADE7753_analogSetup(GAIN_1, GAIN_1, 0, 0, FULLSCALESELECT_0_25V, INTEGRATOR_OFF);  // GAIN1, GAIN2, CH1OS, CH2OS,  ...
; 0001 0012     //ADE7753_rmsSetup( -0, +0 );                 // IRMSOS,VRMSOS  12-bit (S) [-2048 +2048] -- Refer to spec page 25, 2 ...
; 0001 0013     //ADE7753_energySetup(0, 0, 0, 0, 0, 0x0D); // WGAIN,WDIV,APOS,VAGAIN,VADIV,PHCAL  -- Refer to spec page 39, 31, 46, ...
; 0001 0014     //ADE7753_frequencySetup(0, 0);             // CFNUM,CFDEN  12-bit (U) -- for CF pulse output  -- Refer to spec page ...
; 0001 0015     //ADE7753_miscSetup(0, 0, 0, 0, 0, 0);
; 0001 0016 }
;PCODE: $0000000F VOL: 0
;PCODE: $00000010 VOL: 0
;
;/// ADE Driver
;
;/** === enableChip ===
;* Enable chip, setting low ChipSelect pin (CS)
;* @param none
;*
;*/
;void ADE7753_enableChip(void){
; 0001 001F void ADE7753_enableChip(void){
;PCODE: $00000011 VOL: 0
;PCODE: $00000012 VOL: 0
; 0001 0020     CS_ADE;
;PCODE: $00000013 VOL: 0
;PCODE: $00000014 VOL: 0
; 0001 0021 }
;PCODE: $00000015 VOL: 0
;PCODE: $00000016 VOL: 0
;
;/** === disableChip ===
;* Disable chip, setting high ChipSelect pin (CS)
;* @param none
;*
;*/
;void ADE7753_disableChip(void){
; 0001 0028 void ADE7753_disableChip(void){
;PCODE: $00000017 VOL: 0
;PCODE: $00000018 VOL: 0
; 0001 0029     NCS_ADE;
;PCODE: $00000019 VOL: 0
;PCODE: $0000001A VOL: 0
; 0001 002A }
;PCODE: $0000001B VOL: 0
;PCODE: $0000001C VOL: 0
;
;/** === read8 ===
;* Read 8 bits from the device at specified register
;* @param char containing register direction
;* @return char with contents of register
;*
;*/
;unsigned char ADE7753_read8(char reg){
; 0001 0032 unsigned char ADE7753_read8(char reg){
;PCODE: $0000001D VOL: 0
;PCODE: $0000001E VOL: 0
; 0001 0033 
; 0001 0034     unsigned char b0;
; 0001 0035     ADE7753_enableChip();
;PCODE: $0000001F VOL: 0
;PCODE: $00000020 VOL: 0
;	reg -> Y+1
;	b0 -> R17
;PCODE: $00000021 VOL: 0
; 0001 0036     spi(reg);
;PCODE: $00000022 VOL: 0
;PCODE: $00000023 VOL: 0
; 0001 0037     b0=spi(0x00);
;PCODE: $00000024 VOL: 0
;PCODE: $00000025 VOL: 0
;PCODE: $00000026 VOL: 0
; 0001 0038     ADE7753_disableChip();
;PCODE: $00000027 VOL: 0
; 0001 0039     //    return (unsigned long)SPI.transfer(0x00);
; 0001 003A     return b0;
;PCODE: $00000028 VOL: 0
;PCODE: $00000029 VOL: 0
;PCODE: $0000002A VOL: 0
;PCODE: $0000002B VOL: 0
;PCODE: $0000002C VOL: 0
; 0001 003B }
;PCODE: $0000002D VOL: 0
;
;/** === read16 ===
;* Read 16 bits from the device at specified register
;* @param char containing register direction
;* @return int with contents of register
;*
;*/
;unsigned int ADE7753_read16(char reg){
; 0001 0043 unsigned int ADE7753_read16(char reg){
;PCODE: $0000002E VOL: 0
;PCODE: $0000002F VOL: 0
; 0001 0044 
; 0001 0045     unsigned char b1,b0;
; 0001 0046     ADE7753_enableChip();
;PCODE: $00000030 VOL: 0
;PCODE: $00000031 VOL: 0
;	reg -> Y+2
;	b1 -> R17
;	b0 -> R16
;PCODE: $00000032 VOL: 0
; 0001 0047     spi(reg);
;PCODE: $00000033 VOL: 0
;PCODE: $00000034 VOL: 0
; 0001 0048 
; 0001 0049     b1=spi(0x00);
;PCODE: $00000035 VOL: 0
;PCODE: $00000036 VOL: 0
;PCODE: $00000037 VOL: 0
; 0001 004A 
; 0001 004B     b0=spi(0x00);
;PCODE: $00000038 VOL: 0
;PCODE: $00000039 VOL: 0
;PCODE: $0000003A VOL: 0
; 0001 004C 
; 0001 004D     ADE7753_disableChip();
;PCODE: $0000003B VOL: 0
; 0001 004E     return (unsigned int)b1<<8 | (unsigned int)b0;
;PCODE: $0000003C VOL: 0
;PCODE: $0000003D VOL: 0
;PCODE: $0000003E VOL: 0
;PCODE: $0000003F VOL: 0
;PCODE: $00000040 VOL: 0
;PCODE: $00000041 VOL: 0
;PCODE: $00000042 VOL: 0
;PCODE: $00000043 VOL: 0
;PCODE: $00000044 VOL: 0
;PCODE: $00000045 VOL: 0
; 0001 004F }
;PCODE: $00000046 VOL: 0
;
;/** === read24 ===
;* Read 24 bits from the device at specified register
;* @param: char containing register direction
;* @return: char with contents of register
;*
;*/
;unsigned long ADE7753_read24(char reg){
; 0001 0057 unsigned long ADE7753_read24(char reg){
;PCODE: $00000047 VOL: 0
;PCODE: $00000048 VOL: 0
; 0001 0058 
; 0001 0059     unsigned char b2,b1,b0;
; 0001 005A      ADE7753_enableChip();
;PCODE: $00000049 VOL: 0
;PCODE: $0000004A VOL: 0
;	reg -> Y+4
;	b2 -> R17
;	b1 -> R16
;	b0 -> R19
;PCODE: $0000004B VOL: 0
; 0001 005B     spi(reg);
;PCODE: $0000004C VOL: 0
;PCODE: $0000004D VOL: 0
; 0001 005C 
; 0001 005D     b2=spi(0x00);
;PCODE: $0000004E VOL: 0
;PCODE: $0000004F VOL: 0
;PCODE: $00000050 VOL: 0
; 0001 005E 
; 0001 005F     b1=spi(0x00);
;PCODE: $00000051 VOL: 0
;PCODE: $00000052 VOL: 0
;PCODE: $00000053 VOL: 0
; 0001 0060 
; 0001 0061     b0=spi(0x00);
;PCODE: $00000054 VOL: 0
;PCODE: $00000055 VOL: 0
;PCODE: $00000056 VOL: 0
; 0001 0062 
; 0001 0063     ADE7753_disableChip();
;PCODE: $00000057 VOL: 0
; 0001 0064     return (unsigned long)b2<<16 | (unsigned long)b1<<8 | (unsigned long)b0;
;PCODE: $00000058 VOL: 0
;PCODE: $00000059 VOL: 0
;PCODE: $0000005A VOL: 0
;PCODE: $0000005B VOL: 0
;PCODE: $0000005C VOL: 0
;PCODE: $0000005D VOL: 0
;PCODE: $0000005E VOL: 0
;PCODE: $0000005F VOL: 0
;PCODE: $00000060 VOL: 0
;PCODE: $00000061 VOL: 0
;PCODE: $00000062 VOL: 0
;PCODE: $00000063 VOL: 0
;PCODE: $00000064 VOL: 0
;PCODE: $00000065 VOL: 0
;PCODE: $00000066 VOL: 0
;PCODE: $00000067 VOL: 0
;PCODE: $00000068 VOL: 0
;PCODE: $00000069 VOL: 0
;PCODE: $0000006A VOL: 0
;PCODE: $0000006B VOL: 0
;PCODE: $0000006C VOL: 0
; 0001 0065 }
;PCODE: $0000006D VOL: 0
;
;/** === write8 ===
;* Write 8 bits to the device at specified register
;* @param reg char containing register direction
;* @param data char, 8 bits of data to send
;*
;*/
;void ADE7753_write8(char reg, unsigned char data){
; 0001 006D void ADE7753_write8(char reg, unsigned char data){
;PCODE: $0000006E VOL: 0
;PCODE: $0000006F VOL: 0
; 0001 006E 
; 0001 006F     unsigned char data0 = 0;
; 0001 0070     ADE7753_enableChip();
;PCODE: $00000070 VOL: 0
;PCODE: $00000071 VOL: 0
;	reg -> Y+2
;	data -> Y+1
;	data0 -> R17
;PCODE: $00000072 VOL: 0
;PCODE: $00000073 VOL: 0
;PCODE: $00000074 VOL: 0
; 0001 0071     // 8th bit (DB7) of the register address controls the Read/Write mode (Refer to spec page 55 table 13)
; 0001 0072     // For Write -> DB7 = 1  / For Read -> DB7 = 0
; 0001 0073     reg |= WRITE;
;PCODE: $00000075 VOL: 0
;PCODE: $00000076 VOL: 0
;PCODE: $00000077 VOL: 0
; 0001 0074     data0 = (unsigned char)data;
;PCODE: $00000078 VOL: 0
;PCODE: $00000079 VOL: 0
; 0001 0075 
; 0001 0076 
; 0001 0077     spi((unsigned char)reg);          //register selection
;PCODE: $0000007A VOL: 0
;PCODE: $0000007B VOL: 0
; 0001 0078 
; 0001 0079     spi((unsigned char)data0);
;PCODE: $0000007C VOL: 0
;PCODE: $0000007D VOL: 0
; 0001 007A 
; 0001 007B     ADE7753_disableChip();
;PCODE: $0000007E VOL: 0
; 0001 007C }
;PCODE: $0000007F VOL: 0
;PCODE: $00000080 VOL: 0
;PCODE: $00000081 VOL: 0
;PCODE: $00000082 VOL: 0
;PCODE: $00000083 VOL: 0
;
;
;/** === write16 ===
;* Write 16 bits to the device at specified register
;* @param reg: char containing register direction
;* @param data: int, 16 bits of data to send
;*
;*/
;void ADE7753_write16(char reg, unsigned int data){
; 0001 0085 void ADE7753_write16(char reg, unsigned int data){
;PCODE: $00000084 VOL: 0
;PCODE: $00000085 VOL: 0
; 0001 0086 
; 0001 0087     unsigned char data0=0,data1=0;
; 0001 0088     ADE7753_enableChip();
;PCODE: $00000086 VOL: 0
;PCODE: $00000087 VOL: 0
;	reg -> Y+4
;	data -> Y+2
;	data0 -> R17
;	data1 -> R16
;PCODE: $00000088 VOL: 0
;PCODE: $00000089 VOL: 0
;PCODE: $0000008A VOL: 0
;PCODE: $0000008B VOL: 0
;PCODE: $0000008C VOL: 0
; 0001 0089     // 8th bit (DB7) of the register address controls the Read/Write mode (Refer to spec page 55 table 13)
; 0001 008A     // For Write -> DB7 = 1  / For Read -> DB7 = 0
; 0001 008B     reg |= WRITE;
;PCODE: $0000008D VOL: 0
;PCODE: $0000008E VOL: 0
;PCODE: $0000008F VOL: 0
; 0001 008C     //split data
; 0001 008D     data0 = (unsigned char)data;
;PCODE: $00000090 VOL: 0
;PCODE: $00000091 VOL: 0
; 0001 008E     data1 = (unsigned char)(data>>8);
;PCODE: $00000092 VOL: 0
;PCODE: $00000093 VOL: 0
; 0001 008F 
; 0001 0090     //register selection, we have to send a 1 on the 8th bit to perform a write
; 0001 0091 
; 0001 0092     spi((unsigned char)reg);
;PCODE: $00000094 VOL: 0
;PCODE: $00000095 VOL: 0
; 0001 0093 
; 0001 0094     //data send, MSB first
; 0001 0095     spi((unsigned char)data1);
;PCODE: $00000096 VOL: 0
;PCODE: $00000097 VOL: 0
; 0001 0096 
; 0001 0097     spi((unsigned char)data0);
;PCODE: $00000098 VOL: 0
;PCODE: $00000099 VOL: 0
; 0001 0098 
; 0001 0099     ADE7753_disableChip();
;PCODE: $0000009A VOL: 0
; 0001 009A }
;PCODE: $0000009B VOL: 0
;PCODE: $0000009C VOL: 0
;PCODE: $0000009D VOL: 0
;PCODE: $0000009E VOL: 0
;
;
;/*****************************
;*
;*     public functions
;*
;*****************************/
;
;
;/**
;* In general:
;* @params:  void
;* @return: register content (measure) of the proper type depending on register width
;*/
;
;/** === setMode / getMode ===
;* This is a 16-bit register through which most of the ADE7753 functionality is accessed.
;* Signal sample rates, filter enabling, and calibration modes are selected by writing to this register.
;* The contents can be read at any time.
;*
;*
;* The next table describes the functionality of each bit in the register:
;*
;* Bit     Location    Bit Mnemonic    Default Value Description
;* 0       DISHPF       0            HPF (high-pass filter) in Channel 1 is disabled when this bit is set.
;* 1       DISLPF2      0            LPF (low-pass filter) after the multiplier (LPF2) is disabled when this bit is set.
;* 2       DISCF        1            Frequency output CF is disabled when this bit is set.
;* 3       DISSAG       1            Line voltage sag detection is disabled when this bit is set.
;* 4       ASUSPEND     0            By setting this bit to Logic 1, both ADE7753 A/D converters can be turned off. In no ...
;* 5       TEMPSEL      0            Temperature conversion starts when this bit is set to 1. This bit is automatically r ...
;* 6       SWRST        0            Software Chip Reset. A data transfer should not take place to the ADE7753 for at lea ...
;* 7       CYCMODE      0            Setting this bit to Logic 1 places the chip into line cycle energy accumulation mode ...
;* 8       DISCH1       0            ADC 1 (Channel 1) inputs are internally shorted together.
;* 9       DISCH2       0            ADC 2 (Channel 2) inputs are internally shorted together.
;* 10       SWAP         0            By setting this bit to Logic 1 the analog inputs V2P and V2N are connected to ADC 1 ...
;* 12, 11  DTRT1,0      0            These bits are used to select the waveform register update rate.
;*                         DTRT 1    DTRT0    Update Rate
;*                             0    0    27.9 kSPS (CLKIN/128)
;*                             0    1    14 kSPS (CLKIN/256)
;*                             1    0    7 kSPS (CLKIN/512)
;*                             1    1    3.5 kSPS (CLKIN/1024)
;* 14, 13  WAVSEL1,0    0            These bits are used to select the source of the sampled data for the waveform regist ...
;*                               WAVSEL1, 0    Length    Source
;*                               0            0    24 bits active power signal (output of LPF2)
;*                               0            1    Reserved
;*                               1            0    24 bits Channel 1
;*                               1            1    24 bits Channel 2
;* 15    POAM            0            Writing Logic 1 to this bit allows only positive active power to be accumulated in  ...
;*
;*
;* @param none
;* @return int with the data (16 bits unsigned).
;*/
;void ADE7753_setMode(int m){
; 0001 00D0 void ADE7753_setMode(int m){
;PCODE: $0000009F VOL: 0
;PCODE: $000000A0 VOL: 0
; 0001 00D1     ADE7753_write16(MODE, m);
;PCODE: $000000A1 VOL: 0
;	m -> Y+0
;PCODE: $000000A2 VOL: 0
;PCODE: $000000A3 VOL: 0
;PCODE: $000000A4 VOL: 0
;PCODE: $000000A5 VOL: 0
; 0001 00D2 }
;PCODE: $000000A6 VOL: 0
;PCODE: $000000A7 VOL: 0
;PCODE: $000000A8 VOL: 0
;int ADE7753_getMode(){
; 0001 00D3 int ADE7753_getMode(){
;PCODE: $000000A9 VOL: 0
;PCODE: $000000AA VOL: 0
; 0001 00D4     return ADE7753_read16(MODE);
;PCODE: $000000AB VOL: 0
;PCODE: $000000AC VOL: 0
;PCODE: $000000AD VOL: 0
; 0001 00D5 }
;PCODE: $000000AE VOL: 0
;
;/* The IRQ Interrupt Request pin of the ADE7753 on the Olimex Energy Shield is not wired
;to the Arduino board, so need to poll to service the interrupts.
;See board spec and wiring diagram at:
;http://www.olimex.cl/product_info.php?products_id=797&product__name=Arduino_Energy_Shield
;http://www.olimex.cl/pdf/Main_Sch.pdf
;*/
;
;/** === getInterrupts / setInterrupts
;* ADE7753 interrupts can be deactivated at any time by setting the corresponding
;* bit in this 16-bit enable register to Logic 0. The status register continues
;* to register an interrupt event even if disabled. However, the IRQ output is not activated.
;
;* The next table summarizes the function of each bit in this register:
;*
;* BitLocation / Interrupt Flag / Description
;* 0    AEHF        Indicates that an interrupt occurred because the active energy register, AENERGY, is more than half f ...
;* 1    SAG            Indicates that an interrupt was caused by a SAG on the line voltage.
;* 2    CYCEND        Indicates the end of energy accumulation over an integer number of half line cycles as defined by t ...
;* 3    WSMP        Indicates that new data is present in the waveform register.
;* 4    ZX            This status bit is set to Logic 0 on the rising and falling edge of the the voltage waveform. See t ...
;* 5    TEMP        Indicates that a temperature conversion result is available in the temperature register.
;* 6    RESET        Indicates the end of a reset (for both software or hardware reset). The corresponding enable bit has ...
;* 7    AEOF        Indicates that the active energy register has overflowed.
;* 8    PKV            Indicates that waveform sample from Channel 2 has exceeded the VPKLVL value.
;* 9    PKI            Indicates that waveform sample from Channel 1 has exceeded the IPKLVL value.
;* 10    VAEHF        Indicates that an interrupt occurred because the active energy register, VAENERGY, is more than hal ...
;* 11    VAEOF        Indicates that the apparent energy register has overflowed.
;* 12    ZXTO        Indicates that an interrupt was caused by a missing zero crossing on the line voltage for the specif ...
;* 13    PPOS        Indicates that the power has gone from negative to positive.
;* 14    PNEG        Indicates that the power has gone from positive to negative.
;* 15    RESERVED    Reserved.
;*
;//Register address
;    IRQEN     0x0A  // interrupts enable register
;    STATUS    0x0B  // interrupts status register
;    RSTSTATUS 0x0C  // interrupts status register but read will reset all interrupt flags
;
;* @param none
;* @return int with the data (16 bits unsigned).
;*/
;int ADE7753_getEnabledInterrupts(void){
; 0001 00FF int ADE7753_getEnabledInterrupts(void){
;PCODE: $000000AF VOL: 0
;PCODE: $000000B0 VOL: 0
; 0001 0100     return ADE7753_read16(IRQEN);
;PCODE: $000000B1 VOL: 0
;PCODE: $000000B2 VOL: 0
;PCODE: $000000B3 VOL: 0
; 0001 0101 }
;PCODE: $000000B4 VOL: 0
;
;/** === getStatus ===
;* This is an 16-bit read-only register. The status register contains information regarding the source of ADE7753 interru ...
;* @param none
;* @return int with the data (16 bits unsigned).
;*/
;int ADE7753_getInterruptStatus(void){
; 0001 0108 int ADE7753_getInterruptStatus(void){
;PCODE: $000000B5 VOL: 0
;PCODE: $000000B6 VOL: 0
; 0001 0109     return ADE7753_read16(STATUS);
;PCODE: $000000B7 VOL: 0
;PCODE: $000000B8 VOL: 0
;PCODE: $000000B9 VOL: 0
; 0001 010A }
;PCODE: $000000BA VOL: 0
;
;/** === resetStatus ==
;* Same as the interrupt status register except that the register contents are reset to 0 (all flags cleared) after a rea ...
;* @param none
;* @return int with the data (16 bits unsigned).
;*/
;int ADE7753_getresetInterruptStatus(void){
; 0001 0111 int ADE7753_getresetInterruptStatus(void){
;PCODE: $000000BB VOL: 0
;PCODE: $000000BC VOL: 0
; 0001 0112     return ADE7753_read16(RSTSTATUS);
;PCODE: $000000BD VOL: 0
;PCODE: $000000BE VOL: 0
;PCODE: $000000BF VOL: 0
; 0001 0113 }
;PCODE: $000000C0 VOL: 0
;/** (1) === getActiveEnergyLineSync ===
;* The instantaneous active power is accumulated in this read-only register over
;* the LINECYC number of half line cycles.
;* Used in combination with CYCEND Interrupt Flag and with LINECYC register (nbr of half-cycles)
;* >>> This is the prefered method The advantage of summing the active energy over an integer number
;*     of line cycles is that the sinusoidal component in the active energy is reduced to 0.
;*     This eliminates any ripple in the energy calculation. Energy is calculated more
;*     accurately and in a shorter time because the integration period can be shortened.
;* @param none
;* @return long with the data (24 bits 2-complement signed).
;*/
;long ADE7753_getActiveEnergyLineSync(void){
; 0001 011F long ADE7753_getActiveEnergyLineSync(void){
;PCODE: $000000C1 VOL: 0
;PCODE: $000000C2 VOL: 0
; 0001 0120     return ADE7753_read24(LAENERGY);
;PCODE: $000000C3 VOL: 0
;PCODE: $000000C4 VOL: 0
;PCODE: $000000C5 VOL: 0
; 0001 0121 }
;PCODE: $000000C6 VOL: 0
;
;/** (2) === getApparentEnergyLineSync ===
;* The instantaneous real power is accumulated in this read-only register over
;* the LINECYC number of half line cycles.
;* >>> This is the prefered method The advantage of summing the active energy over an integer number
;*     of line cycles is that the sinusoidal component in the active energy is reduced to 0.
;*     This eliminates any ripple in the energy calculation. Energy is calculated more
;*     accurately and in a shorter time because the integration period can be shortened.
;* @param none
;* @return long with the data (24 bits unsigned).
;*/
;long ADE7753_getApparentEnergyLineSync(void){
; 0001 012D long ADE7753_getApparentEnergyLineSync(void){
;PCODE: $000000C7 VOL: 0
;PCODE: $000000C8 VOL: 0
; 0001 012E     return ADE7753_read24(LVAENERGY);
;PCODE: $000000C9 VOL: 0
;PCODE: $000000CA VOL: 0
;PCODE: $000000CB VOL: 0
; 0001 012F }
;PCODE: $000000CC VOL: 0
;
;/** (3) === getReactiveEnergyLineSync ===
;* The instantaneous reactive power is accumulated in this read-only register over
;* the LINECYC number of half line cycles.
;* >>> This is the prefered method The advantage of summing the active energy over an integer number
;*     of line cycles is that the sinusoidal component in the active energy is reduced to 0.
;*     This eliminates any ripple in the energy calculation. Energy is calculated more
;*     accurately and in a shorter time because the integration period can be shortened.
;* @param none
;* @return long with the data (24 bits 2-complement signed).
;*/
;long ADE7753_getReactiveEnergyLineSync(void){
; 0001 013B long ADE7753_getReactiveEnergyLineSync(void){
;PCODE: $000000CD VOL: 0
;PCODE: $000000CE VOL: 0
; 0001 013C     return ADE7753_read24(LVARENERGY);
;PCODE: $000000CF VOL: 0
;PCODE: $000000D0 VOL: 0
;PCODE: $000000D1 VOL: 0
; 0001 013D }
;PCODE: $000000D2 VOL: 0
;
;/** === getIRMS ===
;* Channel 2 RMS Value (Current Channel).
;* The update rate of the Channel 2 rms measurement is CLKIN/4.
;* To minimize noise, synchronize the reading of the rms register with the zero crossing
;* of the voltage input and take the average of a number of readings.
;* @param none
;* @return long with the data (24 bits unsigned).
;*/
;long ADE7753_getIRMS(void){
; 0001 0147 long ADE7753_getIRMS(void){
;PCODE: $000000D3 VOL: 0
;PCODE: $000000D4 VOL: 0
; 0001 0148     long vv;
; 0001 0149     //char zero;
; 0001 014A     ADE7753_getresetInterruptStatus(); // Clear all interrupts
;PCODE: $000000D5 VOL: 0
;	vv -> Y+0
;PCODE: $000000D6 VOL: 0
; 0001 014B //    zero=PIND.3;
; 0001 014C //    while(PIND.3 == zero);
; 0001 014D     vv=0;
;PCODE: $000000D7 VOL: 0
;PCODE: $000000D8 VOL: 0
; 0001 014E     while( !  ( ADE7753_getInterruptStatus() & ZX )  )   // wait Zero-Crossing
;PCODE: $000000D9 VOL: 0
;PCODE: $000000DA VOL: 0
;PCODE: $000000DB VOL: 0
;PCODE: $000000DC VOL: 0
; 0001 014F     { // wait for the selected interrupt to occur
; 0001 0150         if ( vv > 200)
;PCODE: $000000DD VOL: 0
;PCODE: $000000DE VOL: 0
;PCODE: $000000DF VOL: 0
; 0001 0151         {
; 0001 0152             //printf("no AC");
; 0001 0153             break;
;PCODE: $000000E0 VOL: 0
; 0001 0154         }
; 0001 0155         vv++;
;PCODE: $000000E1 VOL: 0
;PCODE: $000000E2 VOL: 0
;PCODE: $000000E3 VOL: 0
;PCODE: $000000E4 VOL: 0
; 0001 0156     }
;PCODE: $000000E5 VOL: 0
;PCODE: $000000E6 VOL: 0
; 0001 0157     return ADE7753_read24(IRMS);
;PCODE: $000000E7 VOL: 0
;PCODE: $000000E8 VOL: 0
;PCODE: $000000E9 VOL: 0
;PCODE: $000000EA VOL: 0
; 0001 0158 }
;PCODE: $000000EB VOL: 0
;
;/** === getVRMS ===
;* Channel 1 RMS Value (Voltage Channel).
;* The update rate of the Channel 1 rms measurement is CLKIN/4.
;* To minimize noise, synchronize the reading of the rms register with the zero crossing
;* of the voltage input and take the average of a number of readings.
;* @param none
;* @return long with the data (24 bits unsigned).
;*/
;long int ADE7753_getVRMS(void){
; 0001 0162 long int ADE7753_getVRMS(void){
;PCODE: $000000EC VOL: 0
;PCODE: $000000ED VOL: 0
; 0001 0163 
; 0001 0164     int ww=0;
; 0001 0165     //char zero;
; 0001 0166     ADE7753_getresetInterruptStatus(); // Clear all interrupts
;PCODE: $000000EE VOL: 0
;	ww -> R16,R17
;PCODE: $000000EF VOL: 0
;PCODE: $000000F0 VOL: 0
;PCODE: $000000F1 VOL: 0
; 0001 0167     while( !  ( ADE7753_getInterruptStatus() & ZX )  )   // wait Zero-Crossing
;PCODE: $000000F2 VOL: 0
;PCODE: $000000F3 VOL: 0
;PCODE: $000000F4 VOL: 0
;PCODE: $000000F5 VOL: 0
; 0001 0168     { // wait for the selected interrupt to occur
; 0001 0169         if ( ww > 200)
;PCODE: $000000F6 VOL: 0
;PCODE: $000000F7 VOL: 0
;PCODE: $000000F8 VOL: 0
; 0001 016A         {
; 0001 016B             //printf("No AC");
; 0001 016C             break;
;PCODE: $000000F9 VOL: 0
; 0001 016D         }
; 0001 016E         ww++;
;PCODE: $000000FA VOL: 0
;PCODE: $000000FB VOL: 0
;PCODE: $000000FC VOL: 0
; 0001 016F     }
;PCODE: $000000FD VOL: 0
;PCODE: $000000FE VOL: 0
; 0001 0170     //PORTC.5=1;
; 0001 0171     //printf("ww:%d",ww);
; 0001 0172     return ADE7753_read24(VRMS);
;PCODE: $000000FF VOL: 0
;PCODE: $00000100 VOL: 0
;PCODE: $00000101 VOL: 0
;PCODE: $00000102 VOL: 0
; 0001 0173 }
;PCODE: $00000103 VOL: 0
;
;/** === vrms ===
;* Returns the mean of last 100 readings of RMS voltage. Also supress first reading to avoid
;* corrupted data.
;* rms measurement update rate is CLKIN/4.
;* To minimize noise, synchronize the reading of the rms register with the zero crossing
;* of the voltage input and take the average of a number of readings.
;* @param none
;* @return long with RMS voltage value
;*/
;long int ADE7753_vrms(){
; 0001 017E long int ADE7753_vrms(){
;PCODE: $00000104 VOL: 0
;PCODE: $00000105 VOL: 0
; 0001 017F     char i=0;
; 0001 0180     long int v=0;
; 0001 0181     ADE7753_getVRMS();//Ignore first reading to avoid garbage
;PCODE: $00000106 VOL: 0
;PCODE: $00000107 VOL: 0
;PCODE: $00000108 VOL: 0
;PCODE: $00000109 VOL: 0
;PCODE: $0000010A VOL: 0
;PCODE: $0000010B VOL: 0
;PCODE: $0000010C VOL: 0
;PCODE: $0000010D VOL: 0
;PCODE: $0000010E VOL: 0
;PCODE: $0000010F VOL: 0
;	i -> R17
;	v -> Y+1
;PCODE: $00000110 VOL: 0
;PCODE: $00000111 VOL: 0
;PCODE: $00000112 VOL: 0
; 0001 0182     for(i=0;i<10;++i){
;PCODE: $00000113 VOL: 0
;PCODE: $00000114 VOL: 0
;PCODE: $00000115 VOL: 0
;PCODE: $00000116 VOL: 0
;PCODE: $00000117 VOL: 0
;PCODE: $00000118 VOL: 0
;PCODE: $00000119 VOL: 0
;PCODE: $0000011A VOL: 0
;PCODE: $0000011B VOL: 0
; 0001 0183         v+=ADE7753_getVRMS();
;PCODE: $0000011C VOL: 0
;PCODE: $0000011D VOL: 0
;PCODE: $0000011E VOL: 0
;PCODE: $0000011F VOL: 0
; 0001 0184     }
;PCODE: $00000120 VOL: 0
;PCODE: $00000121 VOL: 0
;PCODE: $00000122 VOL: 0
;PCODE: $00000123 VOL: 0
;PCODE: $00000124 VOL: 0
; 0001 0185     return (long int)(v/10);
;PCODE: $00000125 VOL: 0
;PCODE: $00000126 VOL: 0
;PCODE: $00000127 VOL: 0
;PCODE: $00000128 VOL: 0
;PCODE: $00000129 VOL: 0
;PCODE: $0000012A VOL: 0
;PCODE: $0000012B VOL: 0
; 0001 0186 }
;PCODE: $0000012C VOL: 0
;
;/** === irms ===
;* Returns the mean of last 100 readings of RMS current. Also supress first reading to avoid
;* corrupted data.
;* rms measurement update rate is CLKIN/4.
;* To minimize noise, synchronize the reading of the rms register with the zero crossing
;* of the voltage input and take the average of a number of readings.
;* @param none
;* @return long with RMS current value in hundreds of [mA], ie. 6709=67[mA]
;*/
;long ADE7753_irms(){
; 0001 0191 long ADE7753_irms(){
;PCODE: $0000012D VOL: 0
;PCODE: $0000012E VOL: 0
; 0001 0192     char n=0;
; 0001 0193     long i=0;
; 0001 0194     ADE7753_getIRMS();//Ignore first reading to avoid garbage
;PCODE: $0000012F VOL: 0
;PCODE: $00000130 VOL: 0
;PCODE: $00000131 VOL: 0
;PCODE: $00000132 VOL: 0
;PCODE: $00000133 VOL: 0
;PCODE: $00000134 VOL: 0
;PCODE: $00000135 VOL: 0
;PCODE: $00000136 VOL: 0
;PCODE: $00000137 VOL: 0
;PCODE: $00000138 VOL: 0
;	n -> R17
;	i -> Y+1
;PCODE: $00000139 VOL: 0
;PCODE: $0000013A VOL: 0
;PCODE: $0000013B VOL: 0
; 0001 0195     for(n=0;n<10;++n){
;PCODE: $0000013C VOL: 0
;PCODE: $0000013D VOL: 0
;PCODE: $0000013E VOL: 0
;PCODE: $0000013F VOL: 0
;PCODE: $00000140 VOL: 0
;PCODE: $00000141 VOL: 0
;PCODE: $00000142 VOL: 0
;PCODE: $00000143 VOL: 0
;PCODE: $00000144 VOL: 0
; 0001 0196         i+=ADE7753_getIRMS();
;PCODE: $00000145 VOL: 0
;PCODE: $00000146 VOL: 0
;PCODE: $00000147 VOL: 0
;PCODE: $00000148 VOL: 0
; 0001 0197     }
;PCODE: $00000149 VOL: 0
;PCODE: $0000014A VOL: 0
;PCODE: $0000014B VOL: 0
;PCODE: $0000014C VOL: 0
;PCODE: $0000014D VOL: 0
; 0001 0198     return i/10;
;PCODE: $0000014E VOL: 0
;PCODE: $0000014F VOL: 0
;PCODE: $00000150 VOL: 0
;PCODE: $00000151 VOL: 0
;PCODE: $00000152 VOL: 0
;PCODE: $00000153 VOL: 0
;PCODE: $00000154 VOL: 0
; 0001 0199 }
;PCODE: $00000155 VOL: 0
;
;/** === getWaveform ===
;* This read-only register contains the sampled waveform data from either Channel 1,
;* Channel 2, or the active power signal. The data source and the length of the waveform
;* registers are selected by data Bits 14 and 13 in the mode register.
;* - Max sampling CLKIN/128 = 3.579545 MHz / 128 = 27.9 kSPS
;* - Bandwidth 14 kHz
;* - one of four output sample rates can be chosen by using Bits 11 and 12
;*   of the mode register (WAVSEL1,0). The output sample rate
;*   can be 27.9 kSPS, 14 kSPS, 7 kSPS, or 3.5 kSPS
;* - arrivals of new waveform samples after each read is indicated by interrupt
;*   request IRQ, but unfortunatly IRQ is not wired in the Olimex Energy Shield
;* - The interrupt request output, IRQ, signals a new sample
;*   availability by going active low.
;* - In waveform sampling mode, the WSMP bit (Bit 3) in the
;*   interrupt enable register must also be set to Logic 1.
;* - The interrupt request output IRQ stays low until the interrupt
;*   routine reads the reset status register.
;* - Interrupt Flag WSMP (bit location 3) in the Interrupt Status Register
;*   indicates that new data is present in the waveform register.
;*   Therefore arrival of new waveform samples may be indicated by polling
;*   this flag and then reading the 24-bit waveform register
;*   --- we use this polling method for Arduino/Nanode ---
;* - When acquiring waveform data, disable low pass filter in order to
;*   obtain and view all the high harmoniques
;* @param none
;* @return long with the data (24 bits 2-complement signed).
;*/
;long ADE7753_getWaveform(void){  // this function will have to be rewritten for allowing rapid polling
; 0001 01B6 long ADE7753_getWaveform(void){
;PCODE: $00000156 VOL: 0
;PCODE: $00000157 VOL: 0
; 0001 01B7     // of WSMP flag in ISR and getting rapid Waveform data over 1 full cycle
; 0001 01B8     // and storing to Arduino tiny RAM
; 0001 01B9     return ADE7753_read24(WAVEFORM);
;PCODE: $00000158 VOL: 0
;PCODE: $00000159 VOL: 0
;PCODE: $0000015A VOL: 0
; 0001 01BA }
;PCODE: $0000015B VOL: 0
;
;/** === getIpeakReset ===
;* Same as Channel 1 Peak Register except that the register contents are reset to 0 after read.
;* @param none
;* @return long with the data (24 bits 24 bits unsigned).
;*/
;long ADE7753_getIpeakReset(void){
; 0001 01C1 long ADE7753_getIpeakReset(void){
;PCODE: $0000015C VOL: 0
;PCODE: $0000015D VOL: 0
; 0001 01C2     return ADE7753_read24(RSTIPEAK);
;PCODE: $0000015E VOL: 0
;PCODE: $0000015F VOL: 0
;PCODE: $00000160 VOL: 0
; 0001 01C3 }
;PCODE: $00000161 VOL: 0
;
;/** === getVpeakReset ===
;* Same as Channel 2 Peak Register except that the register contents are reset to 0 after a read.
;* @param none
;* @return long with the data (24 bits  unsigned).
;*/
;long ADE7753_getVpeakReset(void){
; 0001 01CA long ADE7753_getVpeakReset(void){
;PCODE: $00000162 VOL: 0
;PCODE: $00000163 VOL: 0
; 0001 01CB     return ADE7753_read24(RSTVPEAK);
;PCODE: $00000164 VOL: 0
;PCODE: $00000165 VOL: 0
;PCODE: $00000166 VOL: 0
; 0001 01CC }
;PCODE: $00000167 VOL: 0
;
;/** === getPeriod ===
;* Period of the Channel 2 (Voltage Channel) Input Estimated by Zero-Crossing Processing.
;* The ADE7753 provides the period measurement of the grid line.
;* The period register is an unsigned 16-bit register and is updated every period.
;* The MSB of this register is always zero.
;* The resolution of this register is 2.2 Î¼s/LSB when CLKIN = 3.579545 MHz,
;* which represents 0.013% when the line fre-quency is 60 Hz.
;* When the line frequency is 60 Hz, the value of the period register is
;* approximately CLKIN/4/32/60 Hz x16 = 7457d.
;* The length of the register enables the measurement of line frequencies as low as 13.9 Hz.
;* @param none
;* @return int with the data (16 bits unsigned).
;*/
;int ADE7753_getPeriod(void){
; 0001 01DB int ADE7753_getPeriod(void){
;PCODE: $00000168 VOL: 0
;PCODE: $00000169 VOL: 0
; 0001 01DC     return ADE7753_read16(PERIOD);
;PCODE: $0000016A VOL: 0
;PCODE: $0000016B VOL: 0
;PCODE: $0000016C VOL: 0
; 0001 01DD }
;PCODE: $0000016D VOL: 0
;
;/** === getTemp ===
;* Force a temperature measure and then returns it. This is done by setting bit 5 HIGH in MODE register.
;* Temperature measuring can't be calibrated, the values used in this function are according to the datasheet
;* (register TEMP is 0x00 at -25 celsius degrees).
;*  The contents of the temperature register are signed (twos complement) with a resolution of
;* approximately 1.5 LSB/ °C. The temperature register produces a code of 0x00 when the ambient
;* temperature is approximately -25°C. The temperature measurement is uncalibrated in the ADE7753
;* and has an offset tolerance as high as ±25 °C.
;* @param none
;* @return char with the temperature in celsius degrees.
;*/
;char ADE7753_getTemp(){
; 0001 01EA char ADE7753_getTemp(){
;PCODE: $0000016E VOL: 0
;PCODE: $0000016F VOL: 0
; 0001 01EB     unsigned int tt;
; 0001 01EC     unsigned char r=0;
; 0001 01ED     long lastMode = 0;
; 0001 01EE     //char zero;
; 0001 01EF 
; 0001 01F0     //zero=PIND.3;// Connect ZX pin on ADE7753 to pin   PIND.3 on MCU
; 0001 01F1     //while(PIND.3 == zero);// wait Zero-Crossing
; 0001 01F2 
; 0001 01F3     lastMode = ADE7753_getMode();
;PCODE: $00000170 VOL: 0
;PCODE: $00000171 VOL: 0
;PCODE: $00000172 VOL: 0
;PCODE: $00000173 VOL: 0
;PCODE: $00000174 VOL: 0
;PCODE: $00000175 VOL: 0
;PCODE: $00000176 VOL: 0
;PCODE: $00000177 VOL: 0
;PCODE: $00000178 VOL: 0
;PCODE: $00000179 VOL: 0
;	tt -> R16,R17
;	r -> R19
;	lastMode -> Y+4
;PCODE: $0000017A VOL: 0
;PCODE: $0000017B VOL: 0
;PCODE: $0000017C VOL: 0
;PCODE: $0000017D VOL: 0
;PCODE: $0000017E VOL: 0
; 0001 01F4     //Temp measure
; 0001 01F5     ADE7753_setMode(TEMPSEL);
;PCODE: $0000017F VOL: 0
;PCODE: $00000180 VOL: 0
;PCODE: $00000181 VOL: 0
; 0001 01F6     ADE7753_getresetInterruptStatus(); // Clear all interrupts
;PCODE: $00000182 VOL: 0
; 0001 01F7     tt=0;
;PCODE: $00000183 VOL: 0
;PCODE: $00000184 VOL: 0
; 0001 01F8 while( ! ( ADE7753_getInterruptStatus() & TEMPREADY ) ) // wait for Temperature measurement to be ready
;PCODE: $00000185 VOL: 0
;PCODE: $00000186 VOL: 0
;PCODE: $00000187 VOL: 0
;PCODE: $00000188 VOL: 0
; 0001 01F9     { // wait for the selected interrupt to occur
; 0001 01FA         if ( tt > 1000)
;PCODE: $00000189 VOL: 0
;PCODE: $0000018A VOL: 0
;PCODE: $0000018B VOL: 0
; 0001 01FB         {
; 0001 01FC              printf("0 AC");
;PCODE: $0000018C VOL: 0
;PCODE: $0000018D VOL: 0
;PCODE: $0000018E VOL: 0
;PCODE: $0000018F VOL: 0
;PCODE: $00000190 VOL: 0
;PCODE: $00000191 VOL: 0
;PCODE: $00000192 VOL: 0
; 0001 01FD             ADE7753_getresetInterruptStatus(); // Clear all interrupts
;PCODE: $00000193 VOL: 0
; 0001 01FE             break;
;PCODE: $00000194 VOL: 0
; 0001 01FF         }
; 0001 0200     }
;PCODE: $00000195 VOL: 0
;PCODE: $00000196 VOL: 0
;PCODE: $00000197 VOL: 0
; 0001 0201     //Read register
; 0001 0202     r= ADE7753_read8(TEMP);
;PCODE: $00000198 VOL: 0
;PCODE: $00000199 VOL: 0
;PCODE: $0000019A VOL: 0
; 0001 0203 
; 0001 0204     //    // Do it twice to make sure
; 0001 0205     //Read register
; 0001 0206     r= ADE7753_read8(TEMP);
;PCODE: $0000019B VOL: 0
;PCODE: $0000019C VOL: 0
;PCODE: $0000019D VOL: 0
; 0001 0207 
; 0001 0208     // Set to the previous mode
; 0001 0209     ADE7753_setMode (lastMode);
;PCODE: $0000019E VOL: 0
;PCODE: $0000019F VOL: 0
; 0001 020A     return (1806*r-25000)/1000;
;PCODE: $000001A0 VOL: 0
;PCODE: $000001A1 VOL: 0
;PCODE: $000001A2 VOL: 0
;PCODE: $000001A3 VOL: 0
;PCODE: $000001A4 VOL: 0
;PCODE: $000001A5 VOL: 0
;PCODE: $000001A6 VOL: 0
;PCODE: $000001A7 VOL: 0
;PCODE: $000001A8 VOL: 0
;PCODE: $000001A9 VOL: 0
;PCODE: $000001AA VOL: 0
; 0001 020B     //return r;
; 0001 020C }
;PCODE: $000001AB VOL: 0
;
;// Functions for manual setting of calibrations
;
;/** === energySetup ===
;* @param
;* @param
;*/
;void ADE7753_energySetup(int wgain, char wdiv, int apos, int vagain, char vadiv, char phcal){
; 0001 0214 void ADE7753_energySetup(int wgain, char wdiv, int apos, int vagain, char vadiv, char phcal){
;PCODE: $000001AC VOL: 0
;PCODE: $000001AD VOL: 0
; 0001 0215     ADE7753_write16(WGAIN,wgain);
;PCODE: $000001AE VOL: 0
;	wgain -> Y+7
;	wdiv -> Y+6
;	apos -> Y+4
;	vagain -> Y+2
;	vadiv -> Y+1
;	phcal -> Y+0
;PCODE: $000001AF VOL: 0
;PCODE: $000001B0 VOL: 0
;PCODE: $000001B1 VOL: 0
;PCODE: $000001B2 VOL: 0
; 0001 0216     ADE7753_write8(WDIV,wdiv);
;PCODE: $000001B3 VOL: 0
;PCODE: $000001B4 VOL: 0
;PCODE: $000001B5 VOL: 0
;PCODE: $000001B6 VOL: 0
; 0001 0217     ADE7753_write16(APOS,apos);
;PCODE: $000001B7 VOL: 0
;PCODE: $000001B8 VOL: 0
;PCODE: $000001B9 VOL: 0
;PCODE: $000001BA VOL: 0
; 0001 0218     ADE7753_write16(VAGAIN,vagain);
;PCODE: $000001BB VOL: 0
;PCODE: $000001BC VOL: 0
;PCODE: $000001BD VOL: 0
;PCODE: $000001BE VOL: 0
; 0001 0219     ADE7753_write8(VADIV,vadiv);
;PCODE: $000001BF VOL: 0
;PCODE: $000001C0 VOL: 0
;PCODE: $000001C1 VOL: 0
;PCODE: $000001C2 VOL: 0
; 0001 021A     ADE7753_write8(PHCAL,phcal);
;PCODE: $000001C3 VOL: 0
;PCODE: $000001C4 VOL: 0
;PCODE: $000001C5 VOL: 0
;PCODE: $000001C6 VOL: 0
; 0001 021B }
;PCODE: $000001C7 VOL: 0
;PCODE: $000001C8 VOL: 0
;PCODE: $000001C9 VOL: 0
;
;
;/** === frequencySetup ===
;* The output frequency on the CF pin is adjusted by writing to this 12-bit
;* read/write registerâ€”see the Energy-to-Frequency Conversion section.
;* @param cfnum: integer containing number (12 bits available unsigned. ie range=[0,4095])
;* @param cfden: the same as cfnum
;*/
;void ADE7753_frequencySetup(int cfnum, int cfden){
; 0001 0224 void ADE7753_frequencySetup(int cfnum, int cfden){
;PCODE: $000001CA VOL: 0
;PCODE: $000001CB VOL: 0
; 0001 0225     ADE7753_write16(CFNUM,cfnum);
;PCODE: $000001CC VOL: 0
;	cfnum -> Y+2
;	cfden -> Y+0
;PCODE: $000001CD VOL: 0
;PCODE: $000001CE VOL: 0
;PCODE: $000001CF VOL: 0
;PCODE: $000001D0 VOL: 0
; 0001 0226     ADE7753_write16(CFDEN,cfden);
;PCODE: $000001D1 VOL: 0
;PCODE: $000001D2 VOL: 0
;PCODE: $000001D3 VOL: 0
;PCODE: $000001D4 VOL: 0
; 0001 0227 }
;PCODE: $000001D5 VOL: 0
;PCODE: $000001D6 VOL: 0
;PCODE: $000001D7 VOL: 0
;
;/** === analogSetup ===
;* This 8-bit register is used to adjust the gain selection for the PGA in Channels 1 and 2
;* @param gain_ch1 char set the PGA channel 1 gain, use constants GAIN_1, GAIN_2, GAIN_4, GAIN_8 and gain_16
;* @param gain_ch2 char set the PGA channel 2 gain, use constants GAIN_1, GAIN_2, GAIN_4, GAIN_8 and gain_16
;* @param os_ch1 char set channel 1 analog offset, range : [-32,32]
;* @param os_ch2 char set channel 1 analog offset, range : [-32,32]
;* @param scale_ch1 char
;* @param integrator_ch1 char
;* @return char with the data (8 bits unsigned).
;*/
;void ADE7753_analogSetup(int gain_ch1, int gain_ch2,int os_ch1,int os_ch2,int scale_ch1,int integrator_ch1){
; 0001 0233 void ADE7753_analogSetup(int gain_ch1, int gain_ch2,int os_ch1,int os_ch2,int scale_ch1,int integrator_ch1){
;PCODE: $000001D8 VOL: 0
;PCODE: $000001D9 VOL: 0
; 0001 0234     unsigned char pga = (gain_ch2<<5) | (scale_ch1<<3) | (gain_ch1); //format is |3 bits PGA2 gain|2 bits full scale|3 b ...
; 0001 0235     int sign = 0;
; 0001 0236     int ch1os = 0, ch2os = 0;
; 0001 0237 
; 0001 0238 
; 0001 0239     ADE7753_write8(GAIN,pga);//write GAIN register, format is |3 bits PGA2 gain|2 bits full scale|3 bits PGA1 gain
;PCODE: $000001DA VOL: 0
;PCODE: $000001DB VOL: 0
;PCODE: $000001DC VOL: 0
;PCODE: $000001DD VOL: 0
;PCODE: $000001DE VOL: 0
;PCODE: $000001DF VOL: 0
;PCODE: $000001E0 VOL: 0
;	gain_ch1 -> Y+18
;	gain_ch2 -> Y+16
;	os_ch1 -> Y+14
;	os_ch2 -> Y+12
;	scale_ch1 -> Y+10
;	integrator_ch1 -> Y+8
;	pga -> R17
;	sign -> R18,R19
;	ch1os -> R20,R21
;	ch2os -> Y+6
;PCODE: $000001E1 VOL: 0
;PCODE: $000001E2 VOL: 0
;PCODE: $000001E3 VOL: 0
;PCODE: $000001E4 VOL: 0
;PCODE: $000001E5 VOL: 0
;PCODE: $000001E6 VOL: 0
;PCODE: $000001E7 VOL: 0
;PCODE: $000001E8 VOL: 0
;PCODE: $000001E9 VOL: 0
;PCODE: $000001EA VOL: 0
;PCODE: $000001EB VOL: 0
;PCODE: $000001EC VOL: 0
;PCODE: $000001ED VOL: 0
;PCODE: $000001EE VOL: 0
;PCODE: $000001EF VOL: 0
;PCODE: $000001F0 VOL: 0
;PCODE: $000001F1 VOL: 0
; 0001 023A 
; 0001 023B     // CH1OS: ch1 offset 6-bit, sign magnitude on Bit-5 then integrator on Bit-7
; 0001 023C     // Refer to spec Page 58 Table 16
; 0001 023D     if(os_ch1<0){
;PCODE: $000001F2 VOL: 0
;PCODE: $000001F3 VOL: 0
;PCODE: $000001F4 VOL: 0
; 0001 023E         sign=1;
;PCODE: $000001F5 VOL: 0
;PCODE: $000001F6 VOL: 0
; 0001 023F         os_ch1=-os_ch1;
;PCODE: $000001F7 VOL: 0
;PCODE: $000001F8 VOL: 0
;PCODE: $000001F9 VOL: 0
; 0001 0240     } else{ sign=0; }
;PCODE: $000001FA VOL: 0
;PCODE: $000001FB VOL: 0
;PCODE: $000001FC VOL: 0
;PCODE: $000001FD VOL: 0
;PCODE: $000001FE VOL: 0
; 0001 0241     ch1os = (integrator_ch1<<7) | (sign<<5) | os_ch1;
;PCODE: $000001FF VOL: 0
;PCODE: $00000200 VOL: 0
;PCODE: $00000201 VOL: 0
;PCODE: $00000202 VOL: 0
;PCODE: $00000203 VOL: 0
;PCODE: $00000204 VOL: 0
;PCODE: $00000205 VOL: 0
;PCODE: $00000206 VOL: 0
;PCODE: $00000207 VOL: 0
;PCODE: $00000208 VOL: 0
;PCODE: $00000209 VOL: 0
; 0001 0242     ADE7753_write8(CH1OS,ch1os);
;PCODE: $0000020A VOL: 0
;PCODE: $0000020B VOL: 0
;PCODE: $0000020C VOL: 0
;PCODE: $0000020D VOL: 0
; 0001 0243 
; 0001 0244     // CH2OS: ch2 offset, sign magnitude (ch2 doesn't have integrator) and the offset applied is inverted (ie offset of  ...
; 0001 0245     if(os_ch2<0){
;PCODE: $0000020E VOL: 0
;PCODE: $0000020F VOL: 0
;PCODE: $00000210 VOL: 0
; 0001 0246         sign=1;
;PCODE: $00000211 VOL: 0
;PCODE: $00000212 VOL: 0
; 0001 0247         os_ch2=-os_ch2;
;PCODE: $00000213 VOL: 0
;PCODE: $00000214 VOL: 0
;PCODE: $00000215 VOL: 0
; 0001 0248     } else{ sign=0; }
;PCODE: $00000216 VOL: 0
;PCODE: $00000217 VOL: 0
;PCODE: $00000218 VOL: 0
;PCODE: $00000219 VOL: 0
;PCODE: $0000021A VOL: 0
; 0001 0249     ch2os = (sign<<5) | os_ch2;
;PCODE: $0000021B VOL: 0
;PCODE: $0000021C VOL: 0
;PCODE: $0000021D VOL: 0
;PCODE: $0000021E VOL: 0
;PCODE: $0000021F VOL: 0
;PCODE: $00000220 VOL: 0
; 0001 024A     ADE7753_write8(CH2OS,ch2os);
;PCODE: $00000221 VOL: 0
;PCODE: $00000222 VOL: 0
;PCODE: $00000223 VOL: 0
;PCODE: $00000224 VOL: 0
; 0001 024B }
;PCODE: $00000225 VOL: 0
;PCODE: $00000226 VOL: 0
;PCODE: $00000227 VOL: 0
;PCODE: $00000228 VOL: 0
;
;/** === rmsSetup ===
;**/
;void ADE7753_rmsSetup(int irmsos, int vrmsos){
; 0001 024F void ADE7753_rmsSetup(int irmsos, int vrmsos){
;PCODE: $00000229 VOL: 0
;PCODE: $0000022A VOL: 0
; 0001 0250     ADE7753_write16(VRMSOS,vrmsos);
;PCODE: $0000022B VOL: 0
;	irmsos -> Y+2
;	vrmsos -> Y+0
;PCODE: $0000022C VOL: 0
;PCODE: $0000022D VOL: 0
;PCODE: $0000022E VOL: 0
;PCODE: $0000022F VOL: 0
; 0001 0251     ADE7753_write16(IRMSOS,irmsos);
;PCODE: $00000230 VOL: 0
;PCODE: $00000231 VOL: 0
;PCODE: $00000232 VOL: 0
;PCODE: $00000233 VOL: 0
; 0001 0252 }
;PCODE: $00000234 VOL: 0
;PCODE: $00000235 VOL: 0
;PCODE: $00000236 VOL: 0
;
;void ADE7753_miscSetup(int zxtout, char sagsyc, char saglvl, char ipklvl, char vpklvl, char tmode){
; 0001 0254 void ADE7753_miscSetup(int zxtout, char sagsyc, char saglvl, char ipklvl, char vpklvl, char tmode){
;PCODE: $00000237 VOL: 0
;PCODE: $00000238 VOL: 0
; 0001 0255     // ZXTOUT 12-bit (U) - Zero-Crossing Timeout
; 0001 0256     // SAGCYC  8-bit (U) - Sag Line Cycle Register.
; 0001 0257     // SAGLVL  8-bit (U) - Sag Voltage Level.
; 0001 0258     // IPKLVL  8-bit (U) - Channel 1 Peak Level Threshold
; 0001 0259     // VPKLVL  8-bit (U) - Channel 2 Peak Level Threshold
; 0001 025A     // TMODE   8-bit (U) - Test Mode Register
; 0001 025B     ADE7753_write16(ZXTOUT,zxtout);
;PCODE: $00000239 VOL: 0
;	zxtout -> Y+5
;	sagsyc -> Y+4
;	saglvl -> Y+3
;	ipklvl -> Y+2
;	vpklvl -> Y+1
;	tmode -> Y+0
;PCODE: $0000023A VOL: 0
;PCODE: $0000023B VOL: 0
;PCODE: $0000023C VOL: 0
;PCODE: $0000023D VOL: 0
; 0001 025C     ADE7753_write8(SAGCYC,sagsyc);
;PCODE: $0000023E VOL: 0
;PCODE: $0000023F VOL: 0
;PCODE: $00000240 VOL: 0
;PCODE: $00000241 VOL: 0
; 0001 025D     ADE7753_write8(SAGLVL,saglvl);
;PCODE: $00000242 VOL: 0
;PCODE: $00000243 VOL: 0
;PCODE: $00000244 VOL: 0
;PCODE: $00000245 VOL: 0
; 0001 025E     ADE7753_write8(IPKLVL,ipklvl);
;PCODE: $00000246 VOL: 0
;PCODE: $00000247 VOL: 0
;PCODE: $00000248 VOL: 0
;PCODE: $00000249 VOL: 0
; 0001 025F     ADE7753_write8(VPKLVL,vpklvl);
;PCODE: $0000024A VOL: 0
;PCODE: $0000024B VOL: 0
;PCODE: $0000024C VOL: 0
;PCODE: $0000024D VOL: 0
; 0001 0260     ADE7753_write8(TMODE,tmode);
;PCODE: $0000024E VOL: 0
;PCODE: $0000024F VOL: 0
;PCODE: $00000250 VOL: 0
;PCODE: $00000251 VOL: 0
; 0001 0261 }
;PCODE: $00000252 VOL: 0
;PCODE: $00000253 VOL: 0
;PCODE: $00000254 VOL: 0
;
;void ADE7753_setInterruptsMask(int Mask16){
; 0001 0263 void ADE7753_setInterruptsMask(int Mask16){
;PCODE: $00000255 VOL: 0
;PCODE: $00000256 VOL: 0
; 0001 0264     ADE7753_write16(IRQEN, Mask16);
;PCODE: $00000257 VOL: 0
;	Mask16 -> Y+0
;PCODE: $00000258 VOL: 0
;PCODE: $00000259 VOL: 0
;PCODE: $0000025A VOL: 0
;PCODE: $0000025B VOL: 0
; 0001 0265 }
;PCODE: $0000025C VOL: 0
;PCODE: $0000025D VOL: 0
;PCODE: $0000025E VOL: 0
;
;void ADE7753_setLineCyc(int d){
; 0001 0267 void ADE7753_setLineCyc(int d){
;PCODE: $0000025F VOL: 0
;PCODE: $00000260 VOL: 0
; 0001 0268     ADE7753_write16(LINECYC,d);
;PCODE: $00000261 VOL: 0
;	d -> Y+0
;PCODE: $00000262 VOL: 0
;PCODE: $00000263 VOL: 0
;PCODE: $00000264 VOL: 0
;PCODE: $00000265 VOL: 0
; 0001 0269 }
;PCODE: $00000266 VOL: 0
;PCODE: $00000267 VOL: 0
;PCODE: $00000268 VOL: 0
;
;/** === printGetResetInterruptStatus ===
;* used for code verification et debugging
;*/
;void ADE7753_printGetResetInterruptStatus(void){
; 0001 026E void ADE7753_printGetResetInterruptStatus(void){
;PCODE: $00000269 VOL: 0
;PCODE: $0000026A VOL: 0
; 0001 026F 
; 0001 0270     //int InterruptMask;
; 0001 0271 
; 0001 0272     //printf("Interrupt Status (binary): ");
; 0001 0273     //InterruptMask = ADE7753_getresetInterruptStatus();
; 0001 0274 }
;PCODE: $0000026B VOL: 0
;PCODE: $0000026C VOL: 0
;
;
;
;/** === chkSum ===
;* Checksum Register. This 6-bit read-only register is equal to the sum of all the ones in the previous read.
;* see the ADE7753 Serial Read Operation section.
;* @param none
;* @return char with the data (6 bits unsigned).
;*/
;char ADE7753_chkSum(){
; 0001 027E char ADE7753_chkSum(){
;PCODE: $0000026D VOL: 0
;PCODE: $0000026E VOL: 0
; 0001 027F     return ADE7753_read8(CHKSUM);
;PCODE: $0000026F VOL: 0
;PCODE: $00000270 VOL: 0
;PCODE: $00000271 VOL: 0
; 0001 0280 }
;PCODE: $00000272 VOL: 0
;
;/** === getActiveEnergy ===
;* Active power is accumulated (integrated) over time in this 24-bit, read-only register
;* @param none
;* @return long with the data (24 bits 2-complement signed).
;*/
;long ADE7753_getActiveEnergy(void){
; 0001 0287 long ADE7753_getActiveEnergy(void){
;PCODE: $00000273 VOL: 0
;PCODE: $00000274 VOL: 0
; 0001 0288     return ADE7753_read24(AENERGY);
;PCODE: $00000275 VOL: 0
;PCODE: $00000276 VOL: 0
;PCODE: $00000277 VOL: 0
; 0001 0289 }
;PCODE: $00000278 VOL: 0
;
;/** === getActiveEnergyReset ===
;* Same as the active energy register except that the register is reset to 0 following a read operation.
;* @param none
;* @return long with the data (24 bits 2-complement signed).
;*/
;long ADE7753_getActiveEnergyReset(void){
; 0001 0290 long ADE7753_getActiveEnergyReset(void){
;PCODE: $00000279 VOL: 0
;PCODE: $0000027A VOL: 0
; 0001 0291     return ADE7753_read24(RAENERGY);
;PCODE: $0000027B VOL: 0
;PCODE: $0000027C VOL: 0
;PCODE: $0000027D VOL: 0
; 0001 0292 }
;PCODE: $0000027E VOL: 0
;
;/** === getApparentEnergy ===
;* Apparent Energy Register. Apparent power is accumulated over time in this read-only register.
;* @param none
;* @return long with the data (24 bits unsigned).
;*/
;long ADE7753_getApparentEnergy(void){
; 0001 0299 long ADE7753_getApparentEnergy(void){
;PCODE: $0000027F VOL: 0
;PCODE: $00000280 VOL: 0
; 0001 029A     return ADE7753_read24(VAENERGY);
;PCODE: $00000281 VOL: 0
;PCODE: $00000282 VOL: 0
;PCODE: $00000283 VOL: 0
; 0001 029B }
;PCODE: $00000284 VOL: 0
;
;/** === getApparentEnergyReset ===
;* Same as the VAENERGY register except that the register is reset to 0 following a read operation.
;* @param none
;* @return long with the data (24 bits unsigned).
;*/
;long ADE7753_getApparentEnergyReset(void){
; 0001 02A2 long ADE7753_getApparentEnergyReset(void){
;PCODE: $00000285 VOL: 0
;PCODE: $00000286 VOL: 0
; 0001 02A3     return ADE7753_read24(RVAENERGY);
;PCODE: $00000287 VOL: 0
;PCODE: $00000288 VOL: 0
;PCODE: $00000289 VOL: 0
; 0001 02A4 }
;PCODE: $0000028A VOL: 0
;
;/** === getCurrentOffset ===
;* Channel 2 RMS Offset Correction Register.
;* @param none
;* @return int with the data (12 bits 2-complement signed).
;*/
;int ADE7753_getCurrentOffset(){
; 0001 02AB int ADE7753_getCurrentOffset(){
;PCODE: $0000028B VOL: 0
;PCODE: $0000028C VOL: 0
; 0001 02AC     return ADE7753_read16(IRMSOS);
;PCODE: $0000028D VOL: 0
;PCODE: $0000028E VOL: 0
;PCODE: $0000028F VOL: 0
; 0001 02AD }
;PCODE: $00000290 VOL: 0
;
;/** === getVoltageOffset ===
;* Channel 2 RMS Offset Correction Register.
;*
;* @param none
;* @return int with the data (12 bits 2-complement's signed).
;*/
;int ADE7753_getVoltageOffset(){
; 0001 02B5 int ADE7753_getVoltageOffset(){
;PCODE: $00000291 VOL: 0
;PCODE: $00000292 VOL: 0
; 0001 02B6     return ADE7753_read16(VRMSOS);
;PCODE: $00000293 VOL: 0
;PCODE: $00000294 VOL: 0
;PCODE: $00000295 VOL: 0
; 0001 02B7 }
;PCODE: $00000296 VOL: 0
;
;/** === setZeroCrossingTimeout / getZeroCrossingTimeout ===
;* Zero-Crossing Timeout. If no zero crossings are detected
;* on Channel 2 within a time period specified by this 12-bit register,
;* the interrupt request line (IRQ) is activated
;* @param none
;* @return int with the data (12 bits unsigned).
;*/
;void ADE7753_setZeroCrossingTimeout(int d){
; 0001 02C0 void ADE7753_setZeroCrossingTimeout(int d){
;PCODE: $00000297 VOL: 0
;PCODE: $00000298 VOL: 0
; 0001 02C1     ADE7753_write16(ZXTOUT,d);
;PCODE: $00000299 VOL: 0
;	d -> Y+0
;PCODE: $0000029A VOL: 0
;PCODE: $0000029B VOL: 0
;PCODE: $0000029C VOL: 0
;PCODE: $0000029D VOL: 0
; 0001 02C2 }
;PCODE: $0000029E VOL: 0
;PCODE: $0000029F VOL: 0
;PCODE: $000002A0 VOL: 0
;int ADE7753_getZeroCrossingTimeout(){
; 0001 02C3 int ADE7753_getZeroCrossingTimeout(){
;PCODE: $000002A1 VOL: 0
;PCODE: $000002A2 VOL: 0
; 0001 02C4     return ADE7753_read16(ZXTOUT);
;PCODE: $000002A3 VOL: 0
;PCODE: $000002A4 VOL: 0
;PCODE: $000002A5 VOL: 0
; 0001 02C5 }
;PCODE: $000002A6 VOL: 0
;
;/** === getSagCycles / setSagCycles ===
;* Sag Line Cycle Register. This 8-bit register specifies the number of
;* consecutive line cycles the signal on Channel 2 must be below SAGLVL
;* before the SAG output is activated.
;* @param none
;* @return char with the data (8 bits unsigned).
;*/
;char ADE7753_getSagCycles(){
; 0001 02CE char ADE7753_getSagCycles(){
;PCODE: $000002A7 VOL: 0
;PCODE: $000002A8 VOL: 0
; 0001 02CF     return ADE7753_read8(SAGCYC);
;PCODE: $000002A9 VOL: 0
;PCODE: $000002AA VOL: 0
;PCODE: $000002AB VOL: 0
; 0001 02D0 }
;PCODE: $000002AC VOL: 0
;void ADE7753_setSagCycles(char d){
; 0001 02D1 void ADE7753_setSagCycles(char d){
;PCODE: $000002AD VOL: 0
;PCODE: $000002AE VOL: 0
; 0001 02D2     ADE7753_write8(SAGCYC,d);
;PCODE: $000002AF VOL: 0
;	d -> Y+0
;PCODE: $000002B0 VOL: 0
;PCODE: $000002B1 VOL: 0
;PCODE: $000002B2 VOL: 0
;PCODE: $000002B3 VOL: 0
; 0001 02D3 }
;PCODE: $000002B4 VOL: 0
;PCODE: $000002B5 VOL: 0
;PCODE: $000002B6 VOL: 0
;
;/** === getLineCyc / setLineCyc ===
;* Line Cycle Energy Accumulation Mode Line-Cycle Register.
;* This 16-bit register is used during line cycle energy accumulation mode
;* to set the number of half line cycles for energy accumulation
;* @param none
;* @return int with the data (16 bits unsigned).
;*/
;int ADE7753_getLineCyc(){
; 0001 02DC int ADE7753_getLineCyc(){
;PCODE: $000002B7 VOL: 0
;PCODE: $000002B8 VOL: 0
; 0001 02DD     return ADE7753_read16(LINECYC);
;PCODE: $000002B9 VOL: 0
;PCODE: $000002BA VOL: 0
;PCODE: $000002BB VOL: 0
; 0001 02DE }
;PCODE: $000002BC VOL: 0
;
;
;/** === getSagVoltageLevel / setSagVoltageLevel ===
;* Sag Voltage Level. An 8-bit write to this register determines at what peak
;* signal level on Channel 2 the SAG pin becomes active. The signal must remain
;* low for the number of cycles specified in the SAGCYC register before the SAG pin is activated
;* @param none
;* @return char with the data (8 bits unsigned).
;*/
;char ADE7753_getSagVoltageLevel(){
; 0001 02E8 char ADE7753_getSagVoltageLevel(){
;PCODE: $000002BD VOL: 0
;PCODE: $000002BE VOL: 0
; 0001 02E9     return ADE7753_read8(SAGLVL);
;PCODE: $000002BF VOL: 0
;PCODE: $000002C0 VOL: 0
;PCODE: $000002C1 VOL: 0
; 0001 02EA }
;PCODE: $000002C2 VOL: 0
;void ADE7753_setSagVoltageLevel(char d){
; 0001 02EB void ADE7753_setSagVoltageLevel(char d){
;PCODE: $000002C3 VOL: 0
;PCODE: $000002C4 VOL: 0
; 0001 02EC     ADE7753_write8(SAGLVL,d);
;PCODE: $000002C5 VOL: 0
;	d -> Y+0
;PCODE: $000002C6 VOL: 0
;PCODE: $000002C7 VOL: 0
;PCODE: $000002C8 VOL: 0
;PCODE: $000002C9 VOL: 0
; 0001 02ED }
;PCODE: $000002CA VOL: 0
;PCODE: $000002CB VOL: 0
;PCODE: $000002CC VOL: 0
;
;/** === getIPeakLevel / setIPeakLevel ===
;* Channel 1 Peak Level Threshold (Current Channel). This register sets the level of the current
;* peak detection. If the Channel 1 input exceeds this level, the PKI flag in the status register is set.
;* @param none
;* @return char with the data (8 bits unsigned).
;*/
;char ADE7753_getIPeakLevel(){
; 0001 02F5 char ADE7753_getIPeakLevel(){
;PCODE: $000002CD VOL: 0
;PCODE: $000002CE VOL: 0
; 0001 02F6     return ADE7753_read8(IPKLVL);
;PCODE: $000002CF VOL: 0
;PCODE: $000002D0 VOL: 0
;PCODE: $000002D1 VOL: 0
; 0001 02F7 }
;PCODE: $000002D2 VOL: 0
;void ADE7753_setIPeakLevel(char d){
; 0001 02F8 void ADE7753_setIPeakLevel(char d){
;PCODE: $000002D3 VOL: 0
;PCODE: $000002D4 VOL: 0
; 0001 02F9     ADE7753_write8(IPKLVL,d);
;PCODE: $000002D5 VOL: 0
;	d -> Y+0
;PCODE: $000002D6 VOL: 0
;PCODE: $000002D7 VOL: 0
;PCODE: $000002D8 VOL: 0
;PCODE: $000002D9 VOL: 0
; 0001 02FA }
;PCODE: $000002DA VOL: 0
;PCODE: $000002DB VOL: 0
;PCODE: $000002DC VOL: 0
;
;/** === getVPeakLevel / setVPeakLevel ===
;* Channel 2 Peak Level Threshold (Voltage Channel). This register sets the level of the
;* voltage peak detection. If the Channel 2 input exceeds this level,
;* the PKV flag in the status register is set.
;* @param none
;* @return char with the data (8bits unsigned).
;*/
;char ADE7753_getVPeakLevel(){
; 0001 0303 char ADE7753_getVPeakLevel(){
;PCODE: $000002DD VOL: 0
;PCODE: $000002DE VOL: 0
; 0001 0304     return ADE7753_read8(VPKLVL);
;PCODE: $000002DF VOL: 0
;PCODE: $000002E0 VOL: 0
;PCODE: $000002E1 VOL: 0
; 0001 0305 }
;PCODE: $000002E2 VOL: 0
;void ADE7753_setVPeakLevel(char d){
; 0001 0306 void ADE7753_setVPeakLevel(char d){
;PCODE: $000002E3 VOL: 0
;PCODE: $000002E4 VOL: 0
; 0001 0307     ADE7753_write8(VPKLVL,d);
;PCODE: $000002E5 VOL: 0
;	d -> Y+0
;PCODE: $000002E6 VOL: 0
;PCODE: $000002E7 VOL: 0
;PCODE: $000002E8 VOL: 0
;PCODE: $000002E9 VOL: 0
; 0001 0308 }
;PCODE: $000002EA VOL: 0
;PCODE: $000002EB VOL: 0
;PCODE: $000002EC VOL: 0
;
;/** === getVpeak ===
;* Channel 2 Peak Register. The maximum input value of the voltage channel since the last read of the register is stored  ...
;* @param none
;* @return long with the data (24 bits unsigned).
;*/
;long ADE7753_getVpeak(void){
; 0001 030F long ADE7753_getVpeak(void){
;PCODE: $000002ED VOL: 0
;PCODE: $000002EE VOL: 0
; 0001 0310     return ADE7753_read24(VPEAK);
;PCODE: $000002EF VOL: 0
;PCODE: $000002F0 VOL: 0
;PCODE: $000002F1 VOL: 0
; 0001 0311 }
;PCODE: $000002F2 VOL: 0
;
;/** === getIpeak ===
;* Channel 1 Peak Register. The maximum input value of the current channel since the last read
;* of the register is stored in this register.
;* @param none
;* @return long with the data (24 bits unsigned) .
;*/
;long ADE7753_getIpeak(void){
; 0001 0319 long ADE7753_getIpeak(void){
;PCODE: $000002F3 VOL: 0
;PCODE: $000002F4 VOL: 0
; 0001 031A     return ADE7753_read24(IPEAK);
;PCODE: $000002F5 VOL: 0
;PCODE: $000002F6 VOL: 0
;PCODE: $000002F7 VOL: 0
; 0001 031B }
;PCODE: $000002F8 VOL: 0
;
;/** === energyGain ===
;* @param
;* @param
;*/
;void ADE7753_energyGain(int wgain, int vagain){
; 0001 0321 void ADE7753_energyGain(int wgain, int vagain){
;PCODE: $000002F9 VOL: 0
;PCODE: $000002FA VOL: 0
; 0001 0322     ADE7753_write16(WGAIN,wgain);
;PCODE: $000002FB VOL: 0
;	wgain -> Y+2
;	vagain -> Y+0
;PCODE: $000002FC VOL: 0
;PCODE: $000002FD VOL: 0
;PCODE: $000002FE VOL: 0
;PCODE: $000002FF VOL: 0
; 0001 0323     ADE7753_write16(VAGAIN,vagain);
;PCODE: $00000300 VOL: 0
;PCODE: $00000301 VOL: 0
;PCODE: $00000302 VOL: 0
;PCODE: $00000303 VOL: 0
; 0001 0324 }
;PCODE: $00000304 VOL: 0
;PCODE: $00000305 VOL: 0
;PCODE: $00000306 VOL: 0
;
;
;/** === getLAENERGY ===
;* Accumulated Active Energy until a fixed number of semi cicles according to the LineCyc register.
;* @param none
;* @return long with the data (24 bits unsigned).
;*/
;
;long ADE7753_get_LAENERGY(void){
; 0001 032D long ADE7753_get_LAENERGY(void){
;PCODE: $00000307 VOL: 0
;PCODE: $00000308 VOL: 0
; 0001 032E 
; 0001 032F     long aux;
; 0001 0330     ADE7753_getresetInterruptStatus(); // Clear all interrupts
;PCODE: $00000309 VOL: 0
;	aux -> Y+0
;PCODE: $0000030A VOL: 0
; 0001 0331       while( !  ( ADE7753_getInterruptStatus() & CYCEND )  )   // wait Zero-Crossing
;PCODE: $0000030B VOL: 0
;PCODE: $0000030C VOL: 0
;PCODE: $0000030D VOL: 0
;PCODE: $0000030E VOL: 0
; 0001 0332     {}
;PCODE: $0000030F VOL: 0
;PCODE: $00000310 VOL: 0
; 0001 0333     aux=ADE7753_read24(LAENERGY);
;PCODE: $00000311 VOL: 0
;PCODE: $00000312 VOL: 0
;PCODE: $00000313 VOL: 0
; 0001 0334     return aux;
;PCODE: $00000314 VOL: 0
;PCODE: $00000315 VOL: 0
;PCODE: $00000316 VOL: 0
; 0001 0335 }
;PCODE: $00000317 VOL: 0
;
;long ADE7753_get_AENERGY(void){
; 0001 0337 long ADE7753_get_AENERGY(void){
;PCODE: $00000318 VOL: 0
;PCODE: $00000319 VOL: 0
; 0001 0338 
; 0001 0339     long aux;
; 0001 033A     ADE7753_getresetInterruptStatus(); // Clear all interrupts
;PCODE: $0000031A VOL: 0
;	aux -> Y+0
;PCODE: $0000031B VOL: 0
; 0001 033B       while( !  ( ADE7753_getInterruptStatus() & CYCEND )  );   // wait Zero-Crossing
;PCODE: $0000031C VOL: 0
;PCODE: $0000031D VOL: 0
;PCODE: $0000031E VOL: 0
;PCODE: $0000031F VOL: 0
;PCODE: $00000320 VOL: 0
;PCODE: $00000321 VOL: 0
; 0001 033C 
; 0001 033D     aux=ADE7753_read24(AENERGY);
;PCODE: $00000322 VOL: 0
;PCODE: $00000323 VOL: 0
;PCODE: $00000324 VOL: 0
; 0001 033E     return aux;
;PCODE: $00000325 VOL: 0
;PCODE: $00000326 VOL: 0
;PCODE: $00000327 VOL: 0
; 0001 033F }
;PCODE: $00000328 VOL: 0
;
;long ADE7753_get_LVAENERGY(void){
; 0001 0341 long ADE7753_get_LVAENERGY(void){
;PCODE: $00000329 VOL: 0
;PCODE: $0000032A VOL: 0
; 0001 0342 
; 0001 0343     long aux;
; 0001 0344     ADE7753_getresetInterruptStatus(); // Clear all interrupts
;PCODE: $0000032B VOL: 0
;	aux -> Y+0
;PCODE: $0000032C VOL: 0
; 0001 0345       while( !  ( ADE7753_getInterruptStatus() & CYCEND )  );   // wait Zero-Crossing
;PCODE: $0000032D VOL: 0
;PCODE: $0000032E VOL: 0
;PCODE: $0000032F VOL: 0
;PCODE: $00000330 VOL: 0
;PCODE: $00000331 VOL: 0
;PCODE: $00000332 VOL: 0
; 0001 0346 
; 0001 0347     aux=ADE7753_read24(LVAENERGY);
;PCODE: $00000333 VOL: 0
;PCODE: $00000334 VOL: 0
;PCODE: $00000335 VOL: 0
; 0001 0348     return aux;
;PCODE: $00000336 VOL: 0
;PCODE: $00000337 VOL: 0
;PCODE: $00000338 VOL: 0
; 0001 0349 }
;PCODE: $00000339 VOL: 0
;long ADE7753_get_LVARENERGY(void){
; 0001 034A long ADE7753_get_LVARENERGY(void){
;PCODE: $0000033A VOL: 0
;PCODE: $0000033B VOL: 0
; 0001 034B 
; 0001 034C     long aux;
; 0001 034D     ADE7753_getresetInterruptStatus(); // Clear all interrupts
;PCODE: $0000033C VOL: 0
;	aux -> Y+0
;PCODE: $0000033D VOL: 0
; 0001 034E       while( !  ( ADE7753_getInterruptStatus() & CYCEND )  );   // wait Zero-Crossing
;PCODE: $0000033E VOL: 0
;PCODE: $0000033F VOL: 0
;PCODE: $00000340 VOL: 0
;PCODE: $00000341 VOL: 0
;PCODE: $00000342 VOL: 0
;PCODE: $00000343 VOL: 0
; 0001 034F 
; 0001 0350     aux=ADE7753_read24(LVARENERGY);
;PCODE: $00000344 VOL: 0
;PCODE: $00000345 VOL: 0
;PCODE: $00000346 VOL: 0
; 0001 0351     return aux;
;PCODE: $00000347 VOL: 0
;PCODE: $00000348 VOL: 0
;PCODE: $00000349 VOL: 0
; 0001 0352 }
;PCODE: $0000034A VOL: 0
;void ADE7753_get_ENERGY(long e1,long e2)
; 0001 0354 {
;PCODE: $0000034B VOL: 0
;PCODE: $0000034C VOL: 0
; 0001 0355 
; 0001 0356     ADE7753_getresetInterruptStatus(); // Clear all interrupts
;PCODE: $0000034D VOL: 0
;	e1 -> Y+4
;	e2 -> Y+0
;PCODE: $0000034E VOL: 0
; 0001 0357       while( !  ( ADE7753_getInterruptStatus() & CYCEND )  );   // wait Zero-Crossing
;PCODE: $0000034F VOL: 0
;PCODE: $00000350 VOL: 0
;PCODE: $00000351 VOL: 0
;PCODE: $00000352 VOL: 0
;PCODE: $00000353 VOL: 0
;PCODE: $00000354 VOL: 0
; 0001 0358     e1=ADE7753_read24(LAENERGY);
;PCODE: $00000355 VOL: 0
;PCODE: $00000356 VOL: 0
;PCODE: $00000357 VOL: 0
; 0001 0359     e2=ADE7753_read24(LVAENERGY);
;PCODE: $00000358 VOL: 0
;PCODE: $00000359 VOL: 0
;PCODE: $0000035A VOL: 0
; 0001 035A 
; 0001 035B }
;PCODE: $0000035B VOL: 0
;PCODE: $0000035C VOL: 0
;PCODE: $0000035D VOL: 0
;
;
;
;
